#include <iostream>

#include "memory.hpp"
// generated by xxd -i ...
#include "48rom.h"
#include "diagrom.h"
#include "diagrom2.h"
#include "1280.h"
#include "1281.h"
#include "trdos.h"
#include "trdos604.h"

Memory::Memory()
{
    // clear all 128k memory
    for (int i = 0; i < 8; i++)
    {
        for (int b = 0; b < 16384; b++)
        {
            bank[i][b] = 0x00;
        }
    }
    canWriteRom = false;
    is48 = true;
    bankMapping[0] = 0; // 0 ROM - specially, mapped to 0x0000-0x3fff
    bankMapping[1] = 5; // bank 5 mapped to 0x4000-0x7fff
    bankMapping[2] = 2; // bank 2 always mapped to 0x8000-0xbfff
    bankMapping[3] = 0; // bank 0 mapped 0xc000-0xffff
    ULAShadow = false;  // ULA reading from bank 5 (false) or bank 7 (true)
    isTrDos = false;    // No trdos at start
    // load trdos to ROM bank 3
    canWriteRom = true;
    bankMapping[0] = 2;
    for (unsigned int i = 0; i < trdos604_rom_len; i++)
    {
        WriteByte(i, trdos604_rom[i]);
    }
    canWriteRom = false;
    bankMapping[0] = 0;
}

void Memory::writePort(uint16_t port, uint8_t value)
{
    if (port == 0x7ffd)
    {
        if (is48)
        {
            printf("Memory: We are in 48k, so ignoring write to 7ffd\n");
        }
        else
        {
            bankMapping[3] = value & 0x07;
            ULAShadow = (value & 0x08) ? true : false;
            bankMapping[0] = (value & 0x10) ? 1 : 0;
            is48 = (value & 0x20) ? true : false; // disable future using of this port
            // printf("%x -> %x bank %d shadow %d rom %d\n", port, value, bankMapping[3], ULAShadow, bankMapping[0]);
        }
    }
}

uint8_t Memory::ReadByte(uint16_t address)
{
    if (address <= 0x3fff) // ROM 0 or ROM 1
    {
        if (isTrDos && bankMapping[0] == 1) // if no trdos, return usual rom
        {
            return rom[2][address];
        }
        else
        {
            return rom[bankMapping[0]][address];
        }
    }
    if (address >= 0x4000 && address < 0x8000)
    {
        return bank[bankMapping[1]][address - 0x4000];
    }
    if (address >= 0x8000 && address < 0xc000)
    {
        return bank[bankMapping[2]][address - 0x8000];
    }
    // address >= 0xc000
    return bank[bankMapping[3]][address - 0xc000];
}

uint8_t Memory::ULAReadByte(uint16_t address)
{
    if (ULAShadow) // read from shadow
    {
        return bank[7][address - 0x4000];
    }
    else
    {
        return bank[5][address - 0x4000];
    }
}

void Memory::WriteByte(uint16_t address, uint8_t value)
{
    if (address < 0x4000 && canWriteRom == false)
    {
        // printf("Ignoring attempt to write byte to ROM %x %x\n",address,value);
        return;
    }
    if (address <= 0x3fff) // ROM 0 or ROM 1
    {
        rom[bankMapping[0]][address] = value;
    }
    else if (address >= 0x4000 && address < 0x8000)
    {
        bank[bankMapping[1]][address - 0x4000] = value;
    }
    else if (address >= 0x8000 && address < 0xc000)
    {
        bank[bankMapping[2]][address - 0x8000] = value;
    }
    else // address >= 0xc000
    {
        bank[bankMapping[3]][address - 0xc000] = value;
    }
}

void Memory::change48(bool is48s)
{
    is48 = is48s;
}

void Memory::Read48(void)
{
    canWriteRom = true;
    bankMapping[0] = 0;
    for (unsigned int i = 0; i < __48_rom_len; i++)
    {
        WriteByte(i, __48_rom[i]);
    }
    canWriteRom = false;
}

void Memory::Read128(void)
{
    canWriteRom = true;
    bankMapping[0] = 0;
    for (unsigned int i = 0; i < __128_0_rom_len; i++)
    {
        WriteByte(i, __128_0_rom[i]);
    }
    bankMapping[0] = 1;
    for (unsigned int i = 0; i < __128_1_rom_len; i++)
    {
        WriteByte(i, __128_1_rom[i]);
    }
    bankMapping[0] = 0;
    canWriteRom = false;
}

void Memory::ReadDiag(void)
{
    canWriteRom = true;
    bankMapping[0] = 0;
    for (unsigned int i = 0; i < testrom_bin_len; i++)
    {
        WriteByte(i, testrom_bin[i]);
    }
    canWriteRom = false;
}

void Memory::ReadDiag2(void)
{
    canWriteRom = true;
    bankMapping[0] = 0;
    for (unsigned int i = 0; i < DiagROMv_173_len; i++)
    {
        WriteByte(i, DiagROMv_173[i]);
    }
    canWriteRom = false;
}

void Memory::enableTrDos(bool is)
{
    isTrDos = is;
}

bool Memory::checkTrDos(void)
{
    return isTrDos;
}